\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{enumitem}
\usepackage{hyperref}

\title{Assignment 3 -- Moved Object Detection with DETR (Option 2: Pixel Differences)}
\author{Hailemariam Mersha (NetID: hbm9834)}
\date{\today}

\begin{document}

\maketitle

\section{Overview}
This report summarizes my implementation and experiments for the moved-object detection task using DETR. I chose Option 2 from the handout: compute pixel-wise differences between two frames and fine-tune a DETR model to localize the moved objects. The pipeline is end-to-end and COCO-free; it uses the Hugging Face \texttt{DetrImageProcessor} to handle resizing/normalization and to build targets safely.

\section{Method}
\paragraph{Data and pre-processing.} For each sample, I load frame~1 and frame~2, compute the pixel-wise absolute difference (RGB), and parse the matched annotation text file. Only the second-line boxes per match (the moved positions in frame~2) are used as ground truth; tiny boxes are filtered out and a dummy box is inserted only if needed to keep DETR stable. All images stay at native resolution and are fed to \texttt{DetrImageProcessor}, configured with explicit \texttt{shortest\_edge} and \texttt{longest\_edge} to avoid deprecated \texttt{max\_size}.

\paragraph{Model and training.} I fine-tune \texttt{facebook/detr-resnet-50} with a custom 6-class head (unknown, person, car, other\_vehicle, other\_object, bike). The training loop computes loss, validates with loss + precision/recall (IoU 0.5, score 0.5), applies gradient clipping, and saves only the best checkpoint.

\paragraph{Evaluation and visualization.} The evaluation script computes precision/recall and saves four-panel visuals per sample: top row shows initial/final ground-truth boxes (green) on frames 1 and 2; bottom row shows the modelâ€™s predicted boxes (red with scores) on the same frames. Ablation runs reuse the same eval to produce metrics and visuals per setting.

\section{Experiments}
\subsection{Baseline training}
\begin{itemize}[leftmargin=*]
  \item Backbone: DETR-ResNet50 (pretrained ImageNet weights).
  \item Optimizer: AdamW, learning rate $1{\times}10^{-5}$, weight decay $1{\times}10^{-4}$.
  \item Batch size: 2; epochs: 20 (early stop by best val loss).
  \item Best checkpoint: \texttt{outputs/checkpoints/detr\_option2\_all\_best.pth}.
\end{itemize}

Baseline validation metrics (placeholders to update):
\begin{itemize}[leftmargin=*]
  \item Validation loss: \textbf{[fill in]}
  \item Validation precision (IoU 0.5, score 0.5): \textbf{[fill in]}
  \item Validation recall (IoU 0.5, score 0.5): \textbf{[fill in]}
\end{itemize}

\subsection{Ablations}
I ran ablations over fine-tuning scope and learning rate. Each run saved its best checkpoint and was evaluated with the same thresholds.

\begin{center}
\begin{tabular}{@{}lcccc@{}}
\toprule
Setting & LR & Val Loss & Precision & Recall \\
\midrule
all\_lr1e-5 & $1{\times}10^{-5}$ & [fill] & [fill] & [fill] \\
all\_lr5e-5 & $5{\times}10^{-5}$ & [fill] & [fill] & [fill] \\
head\_lr1e-5 & $1{\times}10^{-5}$ & [fill] & [fill] & [fill] \\
head\_lr5e-5 & $5{\times}10^{-5}$ & [fill] & [fill] & [fill] \\
backbone\_lr1e-5 & $1{\times}10^{-5}$ & [fill] & [fill] & [fill] \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Qualitative results}
Four-panel visualizations are saved under:
\begin{itemize}[leftmargin=*]
  \item Baseline eval: \texttt{outputs/eval\_vis/}
  \item Ablation evals: \texttt{outputs/ablation\_eval\_vis/<run\_name>/}
\end{itemize}
Each image shows (top) initial and final GT in green, (bottom) initial and final predictions in red with confidence scores.

\section{Notes and Caveats}
\begin{itemize}[leftmargin=*]
  \item The DETR classifier head is reinitialized for 6 classes; warnings about unused/mismatched weights are expected on load.
  \item Processor sizing uses \texttt{shortest\_edge}/\texttt{longest\_edge} to avoid deprecated \texttt{max\_size}.
  \item To reproduce: run \texttt{sbatch slurm/task3\_job.slurm}; metrics and visuals will be regenerated automatically.
\end{itemize}

\end{document}
